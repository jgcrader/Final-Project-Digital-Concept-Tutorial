# Final-Project-Digital-Concept-Tutorial
## Understanding the Binary System
### By Jonathan Crader

This tutorial is a brief overview of the Binary numbering system - it will give an understanding of what the binary system is, how to interpret it, and how it can be used to understand other numerical systems encountered in information technology.  
The target audience for this tutorial is first-time learners of numbering systems outside of the common decimal systems.

#### What is "The Binary System"?

In computing, the binary system is a base-2 counting system (having only two digits) that represents the system by which a computer "thinks".  
In the case of the numbering system it is written in **1**'s and **0**'s  
In the case of the computers themselves, the numbering system is representative of two states, the "1"s and "0"s respectively representing values such as _true_/_false_, _yes_/_no_, _on_/_off_, and so on. These values are generated by the state of a the smallest processing unit in the machine itself, the _bit_, which has measures an electric charge with a state of "on" (**1**) or "off" (**0**)
The binary code is, then, an assembling of groups of these bits in groups of 8, called a _byte_, from which alphanumeric values can be derived.

#### How do we read it?

Since the base-10 (_decimal_) counting system is what many people grew up learning, first learning to count in the binary system can be confusing.
In decimal, we count _0, 1, 2, 3, 4, 5, 6, 7, 8, 9_ before adding a second digit to reach _10_ and beginning again, creating the _tens_ place, **1**0.
Since bits in a computer only have two states, the option of counting all the through the decimal system would require several bits just to indicate one number and be inefficient.  
Instead, the counting of "0" to "10" in the binary is as follows:  
0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010  
To count in binary, you begin with 0, and when the original number would go on to two, you begin the _twos_ place, with **1**0, then when 3, or **11** would go on to **12**, you add another digit and reset the others, having created the _fours_ place with **1**00.  

This can be confusing, but after a while it becomes a habit to think of numbers a string that builds horizontally, rather than the numbers in the rising vertically to higher values.  
The image below shows another way to visualize the values represented by the different digit places in binary using exponents
![Binary Counting](https://miro.medium.com/max/402/1*O5DcmmXADTdQCNgYYw7Qpw.png)  

In this case, we understand the value of each place by solving for the product of each digit by the exponent values below it, and the sum of those values is the binary number. In this case:  
> 0 x 2^7 = 0  
1 x 2^6 = 64  
0 x 2^5 = 0  
1 x 2^4 = 16  
1 x 2^3 = 8  
0 x 2^2 = 0  
0 x 2^1 = 0  
1 x 2^0 = 1  

_64 + 16 + 8 + 1 = 89_

Thus, the binary number **01011001** is equal to the decimal number **89**

#### Why do we need to know this?

Binary exists mostly in the background of things now - modern programming languages have layers upon layers of microscopic code written into them that in their origins draw on binary logic - but knowing how it works is helpful to understand other kinds of data  
Other similar counting systems with different base numbers exist, and having an understanding of how non-decimal systems function can be helpful.  
For example, the hexadecimal system uses a base sixteen numbering system, using the values _0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F_ before beginning another "place" - like binary, it exists more in the background, but the same logic of replacing counts with different exponents and exchanges applies, albeit in proportions.
